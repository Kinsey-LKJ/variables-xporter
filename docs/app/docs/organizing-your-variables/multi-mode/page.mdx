import { Callout } from 'nextra/components'

# 多模式变量管理

让我们深入探讨如何使用单一出口原则（Single Source of Truth）来优雅地组织和管理多模式变量。这种方法不仅能让你的设计系统更加灵活，还能大大提升维护效率。

## 传统的多模式变量组织方式

让我们先来看看传统的多模式变量组织方式。以明暗主题（Light/Dark Mode）为例，传统做法是在同一个集合中为每个变量设置不同的模式值：

```
┌──────────────────────┬──────────┬──────────┐
│ Collection           │ light    │ dark     │
├──────────────────────┼──────────┼──────────┤
│ colors/primary       │ #E55517  │ #EE6D21  │
│ colors/background    │ #FFFFFF  │ #1F2937  │
│ colors/text         │ #111827  │ #F9FAFB  │
│ font/size/base      │ 16px     │ 16px     │
│ font/size/lg        │ 18px     │ 18px     │
│ font/size/xl        │ 20px     │ 20px     │
│ font/weight/normal  │ 400      │ 400      │
│ font/weight/medium  │ 500      │ 500      │
│ font/weight/bold    │ 700      │ 700      │
│ spacing/base        │ 16px     │ 16px     │
│ spacing/loose       │ 24px     │ 24px     │
│ spacing/tight       │ 8px      │ 8px      │
└──────────────────────┴──────────┴──────────┘
```


这种方法在只处理明暗主题切换时看起来很直观，但随着项目的发展会遇到以下挑战：

1. **变量和模式强耦合**
   - 每个变量都必须为所有模式设置值
   - 即使某些变量（如字体大小、字重和间距）在不同模式下保持不变，也需要重复设置

2. **难以扩展和维护**
   - 所有模式的变化都集中在一个地方，使得变量管理变得复杂
   - 当需要添加新的模式维度（如品牌主题）时，模式组合会呈指数级增长

## 单一出口原则

让我们来看看如何运用单一出口原则来优雅地组织明暗主题变量，这种方法能够让我们的变量管理更加清晰和可维护。

### 1. Design Tokens 集合（主集合）

首先，我们创建一个主集合来存放所有设计变量：

```
┌────────────────────────┬────────────────────────┐
│                        │                        │
│ Design Tokens          │         default        │
│                        │                        │
├────────────────────────┼────────────────────────┤
│                        │                        │
│ colors/primary/DEFAULT │ colors/primary/DEFAULT │
│ colors/zhiyun/600     │ #EE6D21               │
│ colors/zhiyun/500     │ #E55517               │
│ colors/fiveray/600    │ #DA5959               │
│ colors/fiveray/500    │ #C03939               │
│ ...                   │ ...                   │
│                       │                    │
└────────────────────────┴────────────────────────┘
```

这个主集合只包含一个默认模式，它是所有变量的统一入口。那么，如何实现明暗主题的切换呢？这就需要借助另一个专门的主题模式集合。

### 2. Theme Modes 集合

接下来，我们创建一个专门用于管理主题模式的集合：

```
┌────────────────────────┬──────────────────────┬─────────────────────┐
│                        │                      │                     │
│ Theme Modes            │         light        │         dark        │
│                        │                      │                     │
├────────────────────────┼──────────────────────┼─────────────────────┤
│                        │                      │                     │
│ colors/primary/DEFAULT │ colors/primary/light │ colors/primary/dark │
│                        │                      │                     │
└────────────────────────┴──────────────────────┴─────────────────────┘
```

这个集合专门负责存放需要在明暗主题间切换的变量。通过让主集合中的变量引用此集合中的对应变量，我们就能实现优雅的主题切换。

### 变量引用链

```
                ┌────────────────────────┬────────────────────────┐
                │                        │                        │
                │ Design Tokens          │         defalut        │
                │                        │                        │
                ├────────────────────────┼────────────────────────┤
                │                        │                        │
                │ colors/primary/DEFAULT │ colors/primary/DEFAULT─┼───────┐
                │                        │                        │       │
┌──────────────►│ colors/zhiyun/600      │ #E55517                │       │
│               │                        │                        │       │
├──────────────►│ colors/zhiyun/500      │ #C03939                │       │
│               │                        │                        │       │
│               │ ...                    │ ...                    │       │
│               │                        │                        │       │
│               └────────────────────────┴────────────────────────┘       │
│                                                                         │
│                                                                         │
│    ┌────────────────────────────────────────────────────────────────────┘
│    │
│    │
│    │           ┌────────────────────────┬──────────────────────┬─────────────────────┐
│    │           │                        │                      │                     │
│    │           │ Theme Modes            │         light        │         dark        │
│    │           │                        │                      │                     │
│    │           ├────────────────────────┼──────────────────────┼─────────────────────┤
│    │           │                        │                      │                     │
│    └──────────►│ colors/primary/DEFAULT │ colors/zhiyun/600──┐ │ colors/zhiyun/500─┐ │
│                │                        │                    │ │                   │ │
│                │ ...                    │ ...                │ │ ...               │ │
│                │                        │                    │ │                   │ │
│                └────────────────────────┴────────────────────┼─┴───────────────────┼─┘
│                                                              │                     │
│                                                              │                     │
└──────────────────────────────────────────────────────────────┴─────────────────────┘
```

让我们以 `colors/primary/DEFAULT` 为例来详细说明这个工作流程：

1. 在 `Design Tokens` 集合中，这个变量引用了 `Theme Modes` 集合中的同名变量
2. 在 `Theme Modes` 集合中，这个变量在不同模式下设置了不同的值，从而实现了主题切换
3. 重要的是，`Theme Modes` 集合只需包含那些在不同主题下需要变化的变量，其他保持不变的变量无需在此出现

<Callout type="info" emoji="💡">
**使用者视角：** 在 Figma 中，设计师只需从 Design Tokens 集合中选择所需的变量即可，无需关心背后的变量引用关系。这就是单一出口原则的优势 —— 提供一个统一的、清晰的接口。

**导出过程：** 使用 Variables Xporter 插件时，只需导出 Design Tokens 集合的变量。插件会自动追踪每个变量的引用链，确保获取最终的具体值。
</Callout>

